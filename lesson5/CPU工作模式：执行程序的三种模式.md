## 实模式
一个方面是**运行真实的指令**，对指令的动作不作区分，直接执行指令的真实功能，另一方面是**发往内存的地址是真实的**，对任何地址不加限制地发往内存。

### 实模式寄存器
每个寄存器都是 16 位的。

### 实模式下访问内存
![](https://wsmcs.cn/wp-content/uploads/2023/02/实模式下的访问内存.png)
**代码段是由 CS 和 IP 确定的，而栈段是由 SS 和 SP 段确定的。**

### 实模式中断
第一种情况是，中断控制器给 CPU 发送了一个电子信号，CPU 会对这个信号作出应答。随后中断控制器会将中断号发送给 CPU，这是硬件中断。

第二种情况就是 CPU 执行了 INT 指令，这个指令后面会跟随一个常数，这个常数即是软中断号。这种情况是软件中断。

实模式中断表
![](https://wsmcs.cn/wp-content/uploads/2023/02/实模式中断表.png)

## 保护模式
所有的通用寄存器都是 32 位的，还可以单独使用低 16 位，这个低 16 位又可以拆分成两个 8 位寄存器

### 保护模式特权级
![](https://wsmcs.cn/wp-content/uploads/2023/02/CPU特权级示意图.png)

### 保护模式段描述符
目前为止，内存还是分段模型，要对内存进行保护，就可以转换成对段的保护。

多个段描述符在内存中形成全局段描述符表
![](https://wsmcs.cn/wp-content/uploads/2023/02/全局段描述符表.png)

### 保护模式段选择子
由影子寄存器、段描述符索引、描述符表索引、权限级别组成的。

保护模式段选择子：
![保护模式段选择子](https://wsmcs.cn/wp-content/uploads/2023/02/d08ec3163c80a5dd94e488a71588f8a41-scaled.jpg)
上图中影子寄存器是靠硬件来操作的，对系统程序员不可见，是硬件为了减少性能损耗而设计的一个段描述符的高速缓存，不然每次内存访问都要去内存中查表，那性能损失是巨大的，影子寄存器也正好是 64 位，里面存放了 8 字节段描述符数据。

### 保护模式平坦模型
TODO

### 保护模式中断
保护模式下的中断要权限检查，还有特权级的切换，所以就需要扩展中断向量表的信息，即每个中断用一个中断门描述符来表示，也可以简称为中断门

保护模式中断表
![](https://wsmcs.cn/wp-content/uploads/2023/02/实模式中断表.png)

## 长模式
它使 CPU 在现有的基础上有了 64 位的处理能力，既能完成 64 位的数据运算，也能寻址 64 位的地址空间。

### 长模式寄存器
长模式相比于保护模式，增加了一些通用寄存器，并扩展通用寄存器的位宽，所有的通用寄存器都是 64 位，还可以单独使用低 32 位。这个低 32 位可以拆分成一个低 16 位寄存器，低 16 位又可以拆分成两个 8 位寄存器

长模式弱化段模式管理，只保留了权限级别的检查，忽略了段基址和段长度，而地址的检查则交给了 MMU。

